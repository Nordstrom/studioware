#!/bin/sh

#{{{ Copyright
# Studioware package building script
# Copyright 2011 David Woodfall <dave@studioware.org>
# some modification 2011 James Purdy <james@studioware.org>
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#}}}
#{{{ Init 
init()
{
    # Initial configuration
    APPNAME="sepkg"
    VERSION="1.3"
    CONFDIR=/etc/$APPNAME
    mkdir -p $CONFDIR
    CONF=$CONFDIR/$APPNAME.conf
    if [ ! -e "$CONF" ]; then touch $CONF; fi
    source $CONF
    CACHEDIR=${CACHEDIR:-"/var/cache/$APPNAME"}
    CACHEDIR=$CACHEDIR/$SWVERSION
    SRCCACHEDIR=$CACHEDIR/source
    SBCACHEDIR=$CACHEDIR/slackbuilds
    SBSERVER=${SBSERVER:-"http://www.studioware.org/slackbuilds/$SWVERSION"}
    FILELIST=$CACHEDIR/SLACKBUILDS.TXT

    # Create needed folders
    mkdir -p $SRCCACHEDIR
    mkdir -p $SBCACHEDIR
    
    # Set up temp build dir, trap some signals
    TMPROOT=$(mktemp -d -p /tmp $APPNAME-XXXXXX) || exit
    QUEUE=$TMPROOT/queue
    PKGLIST=$TMPROOT/pkglist
    trap "cleanup" HUP INT ABRT QUIT SEGV TERM KILL PIPE STOP TSTP

    # Command aliases
    WGET="wget --no-check-certificate"
    UP="upgradepkg --reinstall --install-new"
}
#}}}
#{{{ Cleanup and exit
cleanup()
{
    rm -rf $TMPROOT
    exit 
}
#}}}
#{{{ Flags
getflags()
{
    if [ "$1" = "update" ]; then { update; cleanup; }; fi
    if [ "$1" = "-u" ]; then { update; cleanup; }; fi
    if [ "$1" = "search" ]; then { search "$2"; cleanup; }; fi
    if [ "$1" = "-s" ]; then { search "$2"; cleanup; }; fi
    if [ "$1" = "delete-cache" ]; then { deletecache; cleanup; }; fi
    if [ "$1" = "delete-source" ]; then { deletesource; cleanup; }; fi
    if [ "$1" = "delete-all" ]; then { deletecache; deletesource; cleanup; }; fi
    if [ "$1" = "latest" ]; then { latest; cleanup; }; fi
    if [ "$1" = "-l" ]; then { latest; cleanup; }; fi
    if [ "$1" = "read" ]; then { readme "$2"; cleanup; }; fi
    if [ "$1" = "-r" ]; then { readme "$2"; cleanup; }; fi
    if [ "$1" = "-h" ]; then {  usage; cleanup; }; fi
    if [ "$1" = "-v" ]; then { echo $APPNAME $VERSION; cleanup; }; fi
    if [ "$1" = "auto" ]; then { AUTOBUILD=1; shift; }; fi
    if [ "$1" = "-a" ]; then { AUTOBUILD=1; shift; }; fi
    if [ "$1" = "build" ]; then { INSTALL=0; BUILD=1; shift; }; fi
    if [ "$1" = "-b" ]; then { INSTALL=0; BUILD=1; shift; }; fi
    if [ "$1" = "install" ]; then { INSTALL=1; BUILD=1; shift; }; fi
    if [ "$1" = "-i" ]; then { INSTALL=1; BUILD=1; shift; }; fi

    if [ "$BUILD" = "1" ]; then { listpkgs "$@"; cleanup; }; fi
}
#}}}
#{{{ Readme
readme()
{
    file=$(grep $1.tar.gz $FILELIST | awk '{print $2}' | cut -d'/' -f1-3)/README
    shortname=$(echo $file | cut -d'/' -f5 | rev | cut -d- -f4- | rev)
    url=$SBSERVER/$file
    curl -s $url | fmt
    cleanup
}
#}}}
#{{{ Latest
latest()
{
    cd /tmp
    LATEST=$(curl -s http://www.studioware.org/$APPNAME/LATEST)
    echo "Installed version: $VERSION. Latest version: $LATEST."
    if [ "$VERSION" != "$LATEST" ]; then
        echo -n "Newer version available. Download it (y/n)? "
        read REPLY
        if [ "$REPLY" = "y" ]; then
            $WGET -O $APPNAME-$LATEST-noarch-1daw.txz \
                http://www.studioware.org/$APPNAME/$APPNAME-$LATEST-noarch-1daw.txz
            $WGET -O sepkg-$LATEST-noarch-1daw.md5 \
                http://www.studioware.org/$APPNAME/$APPNAME-$LATEST-noarch-1daw.md5
            echo -n "Checking md5... "
            md5sum -c $APPNAME-$LATEST-noarch-1daw.md5
            echo "Package saved to /tmp"
            echo -n "Upgrade now (y/n)? "
            read REPLY
            if [ "$REPLY" = "y" ]; then
                $UP $APPNAME-$LATEST-noarch-1daw.txz
            fi
        fi
    fi
}
# }}}
#{{{ Usage
usage()
{
cat << EOF
$APPNAME $VERSION

Usage Examples:
$APPNAME [-a|auto] -b|build package1, package1, ...
$APPNAME [-a|auto] -i|install package1, package1, ...
$APPNAME -s|search <package>

Options:
$APPNAME -a|auto - auto mode with no prompt/dialog (use with care)
$APPNAME -b|build package1, package2 ... - build packages
$APPNAME delete-cache - delete cached SlackBuilds and filelist
$APPNAME delete-source - delete cached sources
$APPNAME delete-all - delete SlackBuilds and sources
$APPNAME -i|install package1, package2 ... - build & install packages
$APPNAME -i|install < <queuefile> - install packages from file
$APPNAME -l|latest - checks for newer version of $APPNAME
$APPNAME -r|read <package> - download and print readme 
$APPNAME -s|search - search for package name or part name
$APPNAME -u|update - syncs with file server
$APPNAME -h - help
$APPNAME -v - give version and exit

Files

/etc/$APPNAME/$APPNAME.conf
EOF
}
#}}}
#{{{ Update
update()
{   
    cd $CACHEDIR || cleanup
    $WGET -O SLACKBUILDS.TXT $SBSERVER/SLACKBUILDS.TXT
    cleanup
}
#}}}
#{{{ List packages
listpkgs()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    if [ ! -r $FILELIST ]; then { echo "No filelist! Did you run update?"; \
        cleanup; } fi

    cd $TMPROOT || cleanup
    unset pkgs

    cl=$*

    if [ -z "$cl" ]; then
        cat /dev/stdin | sed "s/,/\n/g" > $QUEUE
    else
        echo $cl | sed "s/,/\n/g" > $QUEUE
    fi

    while read line
    do
        name=$(echo $line | awk '{print $1}')
        pkg=$(grep $name $FILELIST | awk '{print $2}' | cut -d'/' -f4)
        pkgs=$pkgs" "$pkg
    done < $QUEUE

    for i in $pkgs
    do
        shortname=$(echo $i | cut -d'.' -f1)
        if [ -n "$i" ]; then
            INSTALLLIST=$INSTALLLIST" "$i" "$shortname" ""on "
        fi
    done

    if [ -z "$INSTALLLIST" ]; then cleanup; fi

    if [ $AUTOBUILD -eq "1" ]; then
        # make installist into pkglist, warning: generous grepping may cause
	# too many packages to be built.
        for i in $pkgs
        do
            echo "$i" >> $PKGLIST
        done
    else
        dialog --separate-output --title install --backtitle "$APPNAME $VERSION" \
            --checklist "Choose packages to install:" \
            19 70 13 $INSTALLLIST 2>$PKGLIST
    fi

    if [ $? -ne 0 ]; then cleanup; fi
    if [ -z "$(cat $PKGLIST)" ]; then cleanup; fi
    installpkgs
}
#}}}
#{{{ Install Packages
installpkgs()
{
    cd $TMPROOT || cleanup
    unset pkgs

    for i in $(cat $PKGLIST)
    do
        pkgs=$pkgs" "$(grep $i $FILELIST | awk '{print $2}')
    done

    for i in $pkgs
    do
        if [ -n "$i" ]; then
            b=$(basename $i .tar.gz)
	    if [ ! -r $SBCACHEDIR/$b.tar.gz ]; then
                $WGET -c -O $SBCACHEDIR/$b.tar.gz $SBSERVER/$i
            fi
            tar xf $SBCACHEDIR/$b.tar.gz
            (
             cd $b                                         
             source ./$b.info        
             LOCAL=$(basename $DOWNLOAD)
             $WGET -c -O $SRCCACHEDIR/$LOCAL $DOWNLOAD
             ln -sf $SRCCACHEDIR/$LOCAL .

             if [ "$(md5sum $LOCAL | awk '{print $1}')" != "$MD5SUM" ]; then 
                echo "Checksums don't match. Did you run 'update' first?"
                echo -n "(a)bort or (c)ontinue? "
                read ANS
                if [ "$ANS" != "c" ]; then exit 1; fi
            fi
            options=$(grep $b $QUEUE | cut -f2- | sed "s/$b//;s/\.tar\.gz//g")
 	    eval $options source ./$b.SlackBuild
            if [ "$INSTALL" = "1" ]; then
                $UP $OUTPUT/$PRGNAM-$VERSION-$ARCH-$BUILD$TAG.${PKGTYPE:-tgz}
            fi
            )
            if [ "$?" = "1" ]; then
                cleanup
            fi
        fi
    done

    cleanup
}
#}}}
#{{{ Search
search()
{
    cd $CACHEDIR || { echo "No cache exists! Did you run update?"; cleanup; }
    if [ ! -r $FILELIST ]; then { echo "No filelist! Did you run update?"; \
        cleanup; } fi

    inrepo=$(grep $1 $FILELIST | awk '{print $2}')

    if [ -n "$inrepo" ]; then
        for g in $inrepo
        do
            shortname=$(echo $g | cut -d'/' -f3)
            dir=$(echo $g | cut -d'/' -f2)
            installed=$(ls /var/log/packages/$shortname-[0-9]* 2>/dev/null)

            if [ -e "$installed" ]; then 
                version=$(echo $installed | cut -d'/' -f5 | rev | cut -d- -f3 \
                    | rev)
                echo "[Installed]         $dir/$shortname $version"
            else echo "[Not Installed]     $dir/$shortname"
            fi
        done
    fi
}
#}}}
#{{{ Delete Cache 
deletecache()
{
    echo "Deleting $FILELIST"
    rm -f $FILELIST
    echo "Deleting $SBCACHEDIR/*.tar.gz"
    rm -f $SBCACHEDIR/*.tar.gz

    shift
    arg=$*
    if [ -n "$arg" ]; then
        if [ "$arg" = "all" ]; then
            rm -rf $CACHEDIR
        fi
    fi
    echo "Cache Deleted"
}
#}}}
#{{{ Delete sourc
deletesource()
{
    echo "Deleting $SRCCACHEDIR/*"
    rm -f $SRCCACHEDIR/*

    echo "All Sources Deleted"
}
#}}}
init
getflags "$@"
